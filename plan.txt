lewss进行升级，lewss在收到以<LEWSS>开头的消息时，会自行将其解析，这叫lewss协议
数据包结构为<LEWSS><协议><包种类>[JSON]
目前包种类有
无头包：旧协议，将任何收到的消息无脑转发
无种类（到协议就结束了）：请求协议
accept：批准加入
clients：请求/回复已连接的客户端总数
tell：私聊
group：群组相关
协议握手：向lewss发送一个无种类包，lewss会回复批准加入，其要求协议或包本身，如果回复了批准加入，证明协议匹配可以加入，如果是回复了和自己协议不同的包则或请求协议包本身则应该主动退出
正常工作：加入后客户端本身属于默认组，发送的任何东西都会被原封不动转发
请求已连接客户端总数：{group:”组名，固定存在default默认组和all全部”}，返回{组名：～，amount:数量}
私聊和群组后面再做，先设计onebds
OneBDS1协议错误那里要测试一下，断开连接之后，要确保他断开之后不会再重连，防止卸载失败了他又连接了
OneBDS2工作原理
OneBDS2数据包结构：
<OneBDS><协议><包种类><cuid>[JSON]（正常工作）
<OneBDS>{“type”:”get protocol”,”clientID”:”<cuid>”}（先发送的OneBDS1协议握手）
<OneBDS>{“type”:”reply protocol”,”clientID”:”<cuid>”,”sender”:”<发送者cuid>”,”protocol”:<协议>}（用于回复OneBDS1的协议握手，和OneBDS1一样是必须发送者不是自己且请求者是自己）
解析逻辑：先判断开头是否OneBDS，如果是OneBDS就然后判断下一个字符是{还是<，如果是{就走OneBDS1协议握手，如果是<就走OneBDS2协议，如果都不是就抛出异常；如果是LEWSS就
启动时，OneBDS2会首先连接一次
连接成功时，OneBDS2会先验证服务器是否采用LEWSS协议，如果没有就直接退出，然后会查询默认组里是否有大于等于两个服务器，如果是的话证明除了他之外已经有一个服务器在了，这个服务器将会决定OneBDS协议版本，所以这时OneBDS2会先向组网发送OneBDS1的协议握手（两个来自OneBDS1的特殊包）如果收到了协议2的握手包则开始正常工作，否则会立刻断开连接并将自己卸载，而如果不是的话证明他是第一个，直接加入就行了，具体步骤是服务器将那个connection_verified设置为true之后就什么也不用动了正常工作就行了
断线的时候会把connection_verified设置为false，重连的时候需要重新验证
是否应该取消自己包含lewss的时候就立刻验证成功？

如果收到了
包种类为
join：加入包，表明自己已经准备好加入群组，无json
send：群发包，向所有服务器广播，包括他自己
clients：查询群组中所有服务器cuid列表
replyclients：回复所有服务器cuid列表，{list:cuid[]}
passdown：接力包


OneBDS2
OneBDS2需要有token，但是这个token只管能不能加入，发送的过程中被窃听没有办法
这个版本仍然不能防针对OneBDS的网络攻击
onebds2的基准服务器可以不是固定的
有一个思路或许可以看下，如果基准服务器离线时，检测到组网中只有基准服务器离线，就更换基准服务器，将这个失去基准服务器组网中的另一台服务器指派为基准服务器，此情况下基准服务器将会检测到除自己之外的所有服务器全部离线，那他将会解除基准状态并进入离线保护
考虑到区域网络服务发生故障时，不会所有服务器同时发生离线，所以当基准服务器离线时，会等待设定的时间，如果这段时间内又有其他服务器离线，那么服务器将会把自己标记为离线，否则将会重新指派基准服务器
如果除了基准服务器以外还有其他服务器同时离线，那所有服务器都会进入保护模式
此外这个基准服务器在实现上，会作为PASSDOWN包的起点和终点
协议2加入的PASSDOWN是实现统一数据库的关键
协议2会重新定义并网时候的握手协议，但是会保留对协议1握手协议的兼容
在解包时包会有一个发送模式，判断优先级低于包种类，仅在SEND包中有意义，w为私聊，b为广播
PASSDOWN包的工作原理就是它会在所有在线服务器中规划一条特定的路线，并将路线随PASSDOWN包携带，路线中还可以存储包的定位，当包在上一个服务器中写入数据完成后，它就会被发送至路线中的下一个服务器，PASSDOWN包一定是私聊，内含一个发送者和一个接收者
写入部分是插件必须引入一个JsonFileNet，这个JsonFileNet提供了类似JsonFile的属性方法，他会在本地保存一个json，然后这个json会同步其他端发送过来的更改，

全局配置文件使用git管理，分支合并自动执行，时间戳较新的优先（有待考虑）
